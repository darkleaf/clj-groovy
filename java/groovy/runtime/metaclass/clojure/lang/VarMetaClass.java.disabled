package groovy.runtime.metaclass.clojure.lang;

import groovy.lang.*;
import clojure.lang.*;
import org.codehaus.groovy.runtime.InvokerHelper;


public class VarMetaClass extends DelegatingMetaClass {
    public VarMetaClass(MetaClass metaClass) {
        super(metaClass);
    }
    public VarMetaClass(Class klass) {
        super(klass);
    }

    // хз почему его не нужно реализовывать
    /*
    public Object invokeMethod(Object object, String name, Object arg) {
        System.out.println("invokeMethod(Object object, String name, Object arg)");
        System.out.println(name);
        System.out.println(arg);

        return super.invokeMethod(object, name, arg);
    }
    */

    // и почему не нужно переопределять другие invokeMethod

    // как в groovy.lang.Reference

    // нужно разобраться с всей этой магией, но вроде работает


    // наверное нужно использовать methodMissing
    // а может быть можно просто как-то настроить delegating чтобы делегировал внутрь

    public Object invokeMethod(Object object, String name, Object[] args) {
        System.out.println("invokeMethod(Object object, String name, Object[] args)");
        System.out.println(object);
        System.out.println(name);
        System.out.println(args);

        Var var = (Var) object;
        Object value = var.deref();

        if (value != null) {
            try {
                return InvokerHelper.invokeMethod(value, name, args);
            }
            catch (Exception e) {
                return super.invokeMethod(object, name, args);
            }
        }
        else {
            return super.invokeMethod(object, name, args);
        }
    }
}
