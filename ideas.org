* Design

** compilation unit
Он про то, что есть директория или набор файлов,
и нужно их скомпилить.

и тут вся сущность груви.
Можно в одном файле объявить несколько классов.

А я хотел по одному классу загружать.
Т.е. компилить только один класс.

И тут вариант - лезть еще глубже.


#+begin_src clojure

  (g/load :classes X Y Z
          :objects instance xxx)
#+end_src

Конструкторы сами, т.к. рефлексия.
g/load должен сгенерить класс - маркер.
Что если он может быть загружен, значит все остальное уже скомпилено.

А в нем как раз инфа о скомпиленных классах.
Или даже не класс, а просто edn манифест, что надо грузить,
и положить его в classes при компиляции.

#+begin_src clojure
  (g/load)
#+end_src

заимпортит все классы с большой буквы, и сделает def с маленькой


** загрузка

есть блин
CompilerConfiguration/getScriptExtensions

и не нужно самому файлы грузить


** файлы

смотреть

1. с тем же именем, что и clj
2. директорию с тем же именем

** пакет

есть способ всем проставить пакет,
чтобы не указывать его постоянно.

соглашения над конфигурацией

** типы

с маленькой буквы - var
с большой и Script - выполнить
с большой - заимпортировать

вложенные классы?




* резолвинг в файлах

#+begin_src clojure
  (g/defclass A)
  (g/defclass B)
#+end_src

вроде бы не обзятельно подключать A.

Но у нас расширения задаются снаружи.
И как это будет компилироваться в файлы?

Он таки сам ищет файл.
Но его байткод попадает в classgenCallback.
Видимо через GroovyClassLoader.
Нужно поисследовать.
Может быть получится исользовать тот же механизм для поиска файлов.
Т.к. сейчас я использую свою функцию ~url~.


* POJO

Нужно везде проставить POJO & CompileStatic.
Где нужно выставить CompileDynamic.

Может быть поумолчанию проставлять POJO?
Но как тогда снимать где нужно?

Оно так-то в инкубаторе, но наверное ничего страшного.

Смысл POJO - только не зависить от рантайма груви, а мы зависим.

https://issues.apache.org/jira/browse/GROOVY-7492

#+begin_quote
This opens up some of Groovy's powerful transforms to the wider Java community.
Groovy can effectively be used as a Lombok-style pre-processor for some Java classes.
#+end_quote

* надо разобраться как методы вызываются

Eсли он реализует интерфейс, то неважно как он скомпилен, динамически или статически.

И не обязательно ставить ~@POJO~.

Нужно разобраться.

* api для интеропа

~clojure.java.api.Clojure.var~. Тут нужно явно делать require.
Но уже есть ~requiring-resolve~.
Надо на его основе сделать.

И наверное это просто класс с статическими методами

+ ns
  + пример
    ~def foo = ns 'clojure.core' key 'foo'~, вроде бы можно такой dsl сделать.
  + var
  + key
  + sym
  + ns ? типа сам объект неймспейса возвращать, для работы с функциями ~ns-imports~ и т.п.
+ read
  просто прочитать, пусть будет

Внутри понятно, нужно будет использовать ~Clojure.var~.

* ns

#+begin_src groovy
 ns1 = ns 'foo.bar'
 IFn = ns1.var /x->y/
 Keyword = ns1.keyword /z->v/
 Symbol =  ns1.symbol />>/
#+end_src

Но, вроде бы не стоит полагаться на сами классы, лучше использовать кложовые функции.

типа ~my_var.with(deref)~ лучше, чем ~my_var.deref()~

* макрос ..

#+begin_src clojure
  (g/.. obj (a 42) (b "xxx"))
#+end_src

через InvokeHelper видимо, там есть такой метод для вызова груви методов

еще наверное нужно проперти предусмотреть. Статические методы должны сами заработать.


Вот тут можно подсмотреть идеи
https://github.com/clj-python/libpython-clj


* TODO проставлять arglist и метаданые

Как-то определять списко параметорв и формировать метаданные.

Может быть даже как-то docstring присобачить.
Например, брать из поля скрипта.

Может быть просто прописывать метаданные вручную, в каком-то методе,
но только groovy структурами, а не кложовыми.

#+begin_src groovy
  new Fn() {
    def meta = read("""
      {:arglists (() (x))}
    """)

    def docstring = """
    """

    // или даже сразу класс писать вместо строки
    def tag = "java.lang.String"


    def invoke() {
    }

    def invoke(x) {
    }
  }
#+end_src


Можно даже не делать свой класс, а брать атрибуты через InvokeHelper.
И наверное эти атрибуты должны быть статическими?

Можно интерфейс сделать с дефолтными методами. И доставать мету, не только для функций.

С другой стороны, может быть мету вешать прямо на var в clj файле?


вот так работает, если добавить ~configuration.parameters = true~
#+begin_src clojure
  (->> gr-1
       class
       .getDeclaredMethods
       (filter #(= "invoke" (.getName %)))
       (map #(.getParameters %))
       (map (fn [params]
               (map #(-> % .getName symbol) params))))

  ;; нужно еще отдельно обрабатывать &
#+end_src

* TODO проверки

проверять имя класса и пакет
наверное уже в clj,
но может быть и в груви что-то можно подкрутить

Сейчас я явно импортирую тот класс, что ожидаю, и будет ошибка.
Она не очень информативна, но уже ок.


* compile

когда компилим кложовый неймспейс - компилим и груви.

#+begin_src clojure
  (when *compile-files*)
#+end_src

#+begin_src clojure
  (defn get-proxy-class
    [& bases]
    (let [[super interfaces] (get-super-and-interfaces bases)
          pname (proxy-name super interfaces)]
      (or (RT/loadClassForName pname)
          (let [[cname bytecode] (generate-proxy super interfaces)]
            (. ^DynamicClassLoader (deref clojure.lang.Compiler/LOADER) (defineClass pname bytecode [super interfaces]))))))
#+end_src

~(or (RT/loadClassForName pname) ,,,)~


* TODO написать тест для tap

* TODO defclasses

#+begin_src clojure
  (g/defclasses "FileName") ;; именно строкой, а зачем? оно и так class_es
#+end_src

загружать все классы

делать ли конструкторы?


тут проблема в том, что если делать компиляцию в class файлы,
то нужно сначала попробовать их загрузить, а уже потом компилировать.
И нужно знать имена классов.

И это ничем особо не отличается от обычного и простого defclass
