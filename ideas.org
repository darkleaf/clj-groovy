* DONE class

Если нужно именно class вернуть, то можно сделать так

#+begin_src groovy
  // Constructor это наследник AFunction
  // может быть вынести в интерфейс метод getClass, но зачем?
  new Constuctor() {
    // или вроде того
    Class getClass() {
      MyClass
    }

    def invoke() {
      new MyClass()
    }

    def invoke(x) {
      new MyClass(x)
    }
  }
#+end_src

Т.к. в груви будет передаваться var с Constructor внутри, то можно
добавить экстеншен для Var, чтобы получать class.


С другой стороны, а нужно ли сам класс и конструктор вместе передавать?
Если класс передаем, значит кто-то будет его сам строить.

Подумать еще как всякие orm использовать.
Или как минимум грамматику и jdbi или вроде того.

* DONE пакет

Если оставлять так, как есть, то будет проблема при компиляции.
Т.к. класс в скрипте будет глобальный для пакета, а не вложенный в скрипт.

нужно будет усложнить путь

foo.clj
foo/bar

foo/bar/Script.groovy


если делать анонимный класс, то все ок, он будет inner.

* DONE скрипт или класс?

Пока скрипт выигрывает, т.к. можно любое значение положить в var,
например не только функцию, но и класс.
Или даже Groovy Object.

Надо именно класс возвращать, с нулевым конструктором.
Конструктор с параметрами бессмысленен.

А класс если и будет нужен, то можно вешать на него метку-интерфейс,
так и отличать. Или просто сделать другой макрос.

Это решит проблемы с
+ пакетом
+ CompileStatic на анониманый класс
+ уберет g.l.Reference

* var

Использум clojure var для коммуникации.
Это точно. Не получится динамически классы перезагружать и использовать через import.

* обновление var при сохранении groovy файла

https://github.com/nextjournal/beholder


Писать в stdout ошибку?

Можно еще менять var на функцию, которая будет кидать ошибку компиляции.
Можно наверное сделать опцию, чтобы только в лог? хотя зачем? кто в проде будет менять?


* api для интеропа

~clojure.java.api.Clojure.var~. Тут нужно явно делать require.
Но уже есть ~requiring-resolve~.
Надо на его основе сделать.

И наверное это просто класс с статическими методами

+ ns
  + пример
    ~def foo = ns 'clojure.core' key 'foo'~, вроде бы можно такой dsl сделать.
  + var
  + key
  + sym
  + ns ? типа сам объект неймспейса возвращать, для работы с функциями ~ns-imports~ и т.п.
+ read
  просто прочитать, пусть будет

Внутри понятно, нужно будет использовать ~Clojure.var~.

* ns

#+begin_src groovy
 ns1 = ns 'foo.bar'
 IFn = ns1.var /x->y/
 Keyword = ns1.keyword /z->v/
 Symbol =  ns1.symbol />>/
#+end_src

Но, вроде бы не стоит полагаться на сами классы, лучше использовать кложовые функции.

типа ~my_var.with(deref)~ лучше, чем ~my_var.deref()~


* TODO meta class для Var
чтобы проксировать без deref

Для IDeref это точно не нужно, т.к. может контракт какой-то нарушит,
а для Var - ok

вроде
#+begin_src groovy
  my_var.foo
  my_var.bar

  // тут точно у одного объекта спрашивали
  x = my_var.deref()
  x.foo
  x.bar
#+end_src

У меня был просчет в бенчмарке и там разница в разы,
может быть и будет иметь смысл сделать мета-класс.

Может быть там только должен быть метод-миссинг?

* DONE разобраться с groovy.lang.Reference

может быть стоит делать final при var('cc', 'map')

может быть нужно скрипту реализовывать IFn.
может быть из invoke() вызывать run()?

или свой какой-то класс сделать

перешли на класс вместо скрипта, наверное не актуально


* почитать про DSL

Наверное по умолчанию не нужно ничего особо настраивать,
разве заимпортить dsl для интеропа


https://docs.groovy-lang.org/latest/html/documentation/core-domain-specific-languages.html

+ можно класс скрипта задавать через аннотации
  наверное можно сразу AFn использовать и просто методы объявлять
+ есть еще какой-то dsl для объявления настроек компилятора
  + можно автоимпортить всякое
  + можно compilestatic всем выставить

* конфигурировать

Сейчас похоже можно просто подложить другой конфиг.
Но если нужно несколько конфигов?

* DONE fn

#+begin_src groovy
  fn { it + 1 }
#+end_src

наверное так не стоит делать


* MyAbstractFn

сделать вроде AFn, но чтобы методы были абстрактные.
Может быть замыкание получится преобразовать

{ ... } as MyAbstractFn

не факт, что получится

* DONE трансформация

всем ifn заменить .call на .invoke.

в groovy 5 не будет такой фичи для call

* DONE trait

не нужно

#+begin_src groovy
  trait ClosureFn implements IFn {
    def invoke() {
      call()
    }

    def invoke(a1) {
      call(a1)
    }

    def invoke(a1, a2) {
      call a1, a2
    }
  }

  { ... } as ClosureFn
#+end_src

создает объект с IFn, но без Closure

* макрос ..

#+begin_src clojure
  (g/.. obj (a 42) (b "xxx"))
#+end_src

через InvokeHelper видимо, там есть такой метод для вызова груви методов


* TODO проставлять arglist и метаданые

Как-то определять списко параметорв и формировать метаданные.

Может быть даже как-то docstring присобачить.
Например, брать из поля скрипта.

Может быть просто прописывать метаданные вручную, в каком-то методе,
но только groovy структурами, а не кложовыми.

#+begin_src groovy
  new Fn() {
    def meta = read("""
      {:arglists (() (x))}
    """)

    def docstring = """
    """

    def tag = "java.lang.String"


    def invoke() {
    }

    def invoke(x) {
    }
  }
#+end_src


Можно даже не делать свой класс, а брать атрибуты через InvokeHelper.

И наверное эти атрибуты должны быть статическими?


вот так работае, если добавить ~configuration.parameters = true~
#+begin_src clojure
  (->> gr-1
       class
       .getDeclaredMethods
       (filter #(= "invoke" (.getName %)))
       (map #(.getParameters %))
       (map (fn [params]
               (map #(-> % .getName symbol) params))))
#+end_src


* TODO расширения и дженерики

#+begin_src groovy
  // вместо такого
  IFn mapv = (IFn) var('clojure.core', 'mapv').with(deref)

  // сделать
  IFn mapv = var('clojure.core', 'mapv').with<IFn>(deref)

  // может быть это позволит писать так:
  IFn mapv = var 'clojure.core', 'mapv' with<IFn> deref
#+end_src

#+begin_src java
  public static <R> R xwith(
      Object self, IFn f
  ) {
      // разобраться с этой штукой
      //@SuppressWarning("unchecked")

      return (R) f.invoke(self);
  }
#+end_src

и вроде как можно вот так писать

#+begin_src groovy
  IFn mapv = var 'clojure.core', 'mapv' with deref
#+end_src

* TODO проверки

проверять имя класса и пакет
наверное уже в clj,
но может быть и в груви что-то можно подкрутить

* TODO перезагрузка

как кидать исключение?
там вроде были комменты в самом неймспейсе
